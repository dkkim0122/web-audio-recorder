var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{T:()=>s});const n=new Blob(["\nclass RecorderWokletProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super()\n    this.bufferChunks = []\n    this.port.onmessage = event => {\n      if (event.data === 'flush') {\n        this.flush()\n      }\n    }\n  }\n\n  process(inputs) {\n    const input = inputs[0]\n    if (input.length > 0) {\n      const channelData = input[0] // only mono channel\n      this.bufferChunks.push(new Float32Array(channelData))\n    }\n    return true\n  }\n\n  flush() {\n    if (this.bufferChunks.length > 0) {\n      const wavBuffer = this.encodeWAV(this.bufferChunks, sampleRate)\n      this.port.postMessage({ wavBuffer }, [wavBuffer])\n      this.bufferChunks = []\n    }\n  }\n\n  encodeWAV(samples, sampleRate) {\n    const WAV_HEADER_LENGTH = 44 // bytes\n    const bufferLength = samples.length * samples[0].length * 2\n    const buffer = new ArrayBuffer(WAV_HEADER_LENGTH + bufferLength)\n    const view = new DataView(buffer)\n\n    // pack WAV header\n    this.writeString(view, 0, 'RIFF')\n    view.setUint32(4, 36 + bufferLength, true)\n    this.writeString(view, 8, 'WAVE')\n    this.writeString(view, 12, 'fmt ')\n    view.setUint32(16, 16, true) // SubChunk1Size\n    view.setUint16(20, 1, true) // AudioFormat (PCM)\n    view.setUint16(22, 1, true) // NumChannels\n    view.setUint32(24, sampleRate, true) // SampleRate\n    view.setUint32(28, sampleRate * 2, true) // ByteRate\n    view.setUint16(32, 2, true) // BlockAlign\n    view.setUint16(34, 16, true) // BitsPerSample\n    this.writeString(view, 36, 'data')\n    view.setUint32(40, bufferLength, true)\n\n    // write audio data\n    let offset = WAV_HEADER_LENGTH\n    for (let i = 0; i < samples.length; i++) {\n      const sample = samples[i]\n      for (let j = 0; j < sample.length; j++) {\n        const s = Math.max(-1, Math.min(1, sample[j]))\n        view.setInt16(offset, s * 0x7fff, true)\n        offset += 2 // 2bytes -> 16bitsì”©\n      }\n    }\n\n    return buffer\n  }\n\n  writeString(view, offset, string) {\n    for (let i = 0; i < string.length; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i))\n    }\n  }\n}\n\nregisterProcessor('recorder-worklet-processor', RecorderWokletProcessor)\n"],{type:"application/javascript"}),r=URL.createObjectURL(n);function s(){const e={mediaStream:null,isRecording:!1,volume:0};let t,n,s,i,a,o;const u=()=>{null!=t&&t.close().catch((()=>{}))};return{requestMicPermission:async t=>{try{const n=await navigator.mediaDevices.getUserMedia(t??{audio:!0});e.mediaStream=n}catch(e){window.alert("You do not have permission for microphone access.")}},startRecording:async({timeSlice:u,sampleRate:c=44e3,enableAnalyzeVolume:l=!0,onDataAvailable:f})=>{if(!e.mediaStream)throw new Error("startRecording: no media stream exists!");t=new AudioContext({sampleRate:c}),n=t.createMediaStreamSource(e.mediaStream),s=t.createAnalyser(),s.fftSize=256,"running"!==t.state&&await t.resume();const d=()=>{const n=new Uint8Array(s.frequencyBinCount);s.getByteFrequencyData(n);const r=n.reduce(((e,t)=>e+t))/n.length;e.volume=Math.round(r)/100,"running"===t?.state&&requestAnimationFrame(d)};await t.audioWorklet.addModule(r),i=new AudioWorkletNode(t,"recorder-worklet-processor"),i.port.onmessage=e=>{const{data:t}=e;if(null!=t.wavBuffer){const e=t.wavBuffer,n=new Blob([e],{type:"audio/wav"});if(void 0!==u&&f)return void f(n);o&&(o(n),o=null)}},void 0!==u&&(a=setInterval((()=>{i.port.postMessage("flush")}),u)),n.connect(s),s.connect(i),l&&d(),e.isRecording=!0},stopRecording:t=>{e.isRecording&&(o=t??null,i.port.postMessage("flush"),clearInterval(a),n.disconnect(s),s.disconnect(i),u(),e.isRecording=!1,e.volume=0)},destroyMediaStream:()=>{null!=e.mediaStream&&e.mediaStream?.getTracks().forEach((e=>{e.stop()})),u(),e.mediaStream=null},getState:()=>({...e})}}var i=t.T;export{i as createAudioRecorder};
//# sourceMappingURL=index.js.map