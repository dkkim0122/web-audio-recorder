{"version":3,"file":"index.js","sources":["../src/worklet/recorderWorkletProcessor.ts","../src/index.ts"],"sourcesContent":["const recorderWorkletProcessor = `\nclass RecorderWokletProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super()\n    this.bufferChunks = []\n    this.port.onmessage = event => {\n      if (event.data === 'flush') {\n        this.flush()\n      }\n    }\n  }\n\n  process(inputs) {\n    const input = inputs[0]\n    if (input.length > 0) {\n      const channelData = input[0] // only mono channel\n      this.bufferChunks.push(new Float32Array(channelData))\n    }\n    return true\n  }\n\n  flush() {\n    if (this.bufferChunks.length > 0) {\n      const wavBuffer = this.encodeWAV(this.bufferChunks, sampleRate)\n      this.port.postMessage({ wavBuffer }, [wavBuffer])\n      this.bufferChunks = []\n    }\n  }\n\n  encodeWAV(samples, sampleRate) {\n    const WAV_HEADER_LENGTH = 44 // bytes\n    const bufferLength = samples.length * samples[0].length * 2\n    const buffer = new ArrayBuffer(WAV_HEADER_LENGTH + bufferLength)\n    const view = new DataView(buffer)\n\n    // pack WAV header\n    this.writeString(view, 0, 'RIFF')\n    view.setUint32(4, 36 + bufferLength, true)\n    this.writeString(view, 8, 'WAVE')\n    this.writeString(view, 12, 'fmt ')\n    view.setUint32(16, 16, true) // SubChunk1Size\n    view.setUint16(20, 1, true) // AudioFormat (PCM)\n    view.setUint16(22, 1, true) // NumChannels\n    view.setUint32(24, sampleRate, true) // SampleRate\n    view.setUint32(28, sampleRate * 2, true) // ByteRate\n    view.setUint16(32, 2, true) // BlockAlign\n    view.setUint16(34, 16, true) // BitsPerSample\n    this.writeString(view, 36, 'data')\n    view.setUint32(40, bufferLength, true)\n\n    // write audio data\n    let offset = WAV_HEADER_LENGTH\n    for (let i = 0; i < samples.length; i++) {\n      const sample = samples[i]\n      for (let j = 0; j < sample.length; j++) {\n        const s = Math.max(-1, Math.min(1, sample[j]))\n        view.setInt16(offset, s * 0x7fff, true)\n        offset += 2 // 2bytes -> 16bitsì”©\n      }\n    }\n\n    return buffer\n  }\n\n  writeString(view, offset, string) {\n    for (let i = 0; i < string.length; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i))\n    }\n  }\n}\n\nregisterProcessor('recorder-worklet-processor', RecorderWokletProcessor)\n`\n\nconst script = new Blob([recorderWorkletProcessor], {\n  type: 'application/javascript',\n})\nconst src = URL.createObjectURL(script)\nexport const RecorderWokletProcessorSrc = src\n","import { RecorderWokletProcessorSrc } from './worklet/recorderWorkletProcessor'\nimport {\n  AudioRecorder,\n  AudioRecorderOptions,\n  AudioRecorderStates,\n} from './types'\n\nfunction createAudioRecorder(): AudioRecorder {\n  const state: AudioRecorderStates = {\n    mediaStream: null,\n    isRecording: false,\n    volume: 0,\n  }\n\n  let audioContext: AudioContext\n  let inputNode: MediaStreamAudioSourceNode\n  let analyzerNode: AnalyserNode\n  let audioWorkletNode: AudioWorkletNode\n  let flushInterval: ReturnType<typeof setInterval>\n  let handleStopCallback: ((blob: Blob) => void) | null\n\n  const stopMediaStream = (): void => {\n    if (state.mediaStream != null) {\n      state.mediaStream?.getTracks().forEach((track) => {\n        track.stop()\n      })\n    }\n  }\n\n  const closeAudioContext = (): void => {\n    if (audioContext != null) {\n      audioContext.close().catch(() => {})\n    }\n  }\n\n  const requestMicPermission = async (\n    contraints?: MediaStreamConstraints\n  ): Promise<void> => {\n    try {\n      const mediaStream = await navigator.mediaDevices.getUserMedia(\n        contraints ?? { audio: true }\n      )\n      state.mediaStream = mediaStream\n    } catch (err) {\n      window.alert('You do not have permission for microphone access.')\n    }\n  }\n\n  const startRecording = async ({\n    timeSlice, // ms\n    sampleRate = 44000, // hz\n    enableAnalyzeVolume = true,\n    onDataAvailable,\n  }: AudioRecorderOptions): Promise<void> => {\n    if (!state.mediaStream) {\n      throw new Error('startRecording: no media stream exists!')\n    }\n    audioContext = new AudioContext({ sampleRate })\n\n    inputNode = audioContext.createMediaStreamSource(state.mediaStream)\n\n    // analyze volume from 0~1\n    analyzerNode = audioContext.createAnalyser()\n    analyzerNode.fftSize = 256\n\n    if (audioContext.state !== 'running') {\n      await audioContext.resume() // for safari\n    }\n\n    const analyzeVolume = (): void => {\n      const arr = new Uint8Array(analyzerNode.frequencyBinCount)\n      analyzerNode.getByteFrequencyData(arr) // amplitude of each frequency bin from 0 to 255\n      const average = arr.reduce((a, b) => a + b) / arr.length\n      state.volume = Math.round(average) / 100\n\n      if (audioContext?.state === 'running') {\n        requestAnimationFrame(analyzeVolume)\n      }\n    }\n\n    // pcm -> wav encode\n    await audioContext.audioWorklet.addModule(RecorderWokletProcessorSrc)\n    audioWorkletNode = new AudioWorkletNode(\n      audioContext,\n      'recorder-worklet-processor'\n    )\n    audioWorkletNode.port.onmessage = (event: MessageEvent) => {\n      const { data } = event\n      if (data.wavBuffer != null) {\n        const wavBuffer = data.wavBuffer as ArrayBuffer\n        const wavBlob = new Blob([wavBuffer], { type: 'audio/wav' })\n\n        if (timeSlice !== undefined && onDataAvailable) {\n          onDataAvailable(wavBlob)\n          return\n        }\n\n        if (handleStopCallback) {\n          handleStopCallback(wavBlob)\n          handleStopCallback = null\n        }\n      }\n    }\n\n    if (timeSlice !== undefined) {\n      flushInterval = setInterval(() => {\n        audioWorkletNode.port.postMessage('flush')\n      }, timeSlice)\n    }\n\n    inputNode.connect(analyzerNode)\n    analyzerNode.connect(audioWorkletNode)\n\n    if (enableAnalyzeVolume) {\n      analyzeVolume()\n    }\n\n    state.isRecording = true\n  }\n\n  const stopRecording = (cb?: (blob: Blob) => void): void => {\n    if (!state.isRecording) return\n\n    handleStopCallback = cb ?? null\n\n    audioWorkletNode.port.postMessage('flush')\n    clearInterval(flushInterval)\n\n    inputNode.disconnect(analyzerNode)\n    analyzerNode.disconnect(audioWorkletNode)\n\n    closeAudioContext()\n    state.isRecording = false\n    state.volume = 0\n  }\n\n  const destroyMediaStream = (): void => {\n    stopMediaStream()\n    closeAudioContext()\n    state.mediaStream = null\n  }\n\n  const getState = () => ({ ...state })\n\n  return {\n    requestMicPermission,\n    startRecording,\n    stopRecording,\n    destroyMediaStream,\n    getState,\n  }\n}\n\nexport { createAudioRecorder }\nexport type {\n  AudioRecorderOptions,\n  AudioRecorderStates,\n  AudioRecorder,\n} from './types'\n"],"names":["script","Blob","type","RecorderWokletProcessorSrc","URL","createObjectURL","createAudioRecorder","state","mediaStream","isRecording","volume","audioContext","inputNode","analyzerNode","audioWorkletNode","flushInterval","handleStopCallback","closeAudioContext","close","catch","requestMicPermission","async","contraints","navigator","mediaDevices","getUserMedia","audio","err","window","alert","startRecording","timeSlice","sampleRate","enableAnalyzeVolume","onDataAvailable","Error","AudioContext","createMediaStreamSource","createAnalyser","fftSize","resume","analyzeVolume","arr","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","length","Math","round","requestAnimationFrame","audioWorklet","addModule","AudioWorkletNode","port","onmessage","event","data","wavBuffer","wavBlob","undefined","setInterval","postMessage","connect","stopRecording","cb","clearInterval","disconnect","destroyMediaStream","getTracks","forEach","track","stop","getState"],"mappings":"AAAA,MA0EMA,EAAS,IAAIC,KAAK,CA1ES,qqEA0EmB,CAClDC,KAAM,2BAGKC,EADDC,IAAIC,gBAAgBL,GCtEhC,SAASM,IACP,MAAMC,EAA6B,CACjCC,YAAa,KACbC,aAAa,EACbC,OAAQ,GAGV,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,MAQMC,EAAoB,KACJ,MAAhBN,GACFA,EAAaO,QAAQC,OAAM,UAiH/B,MAAO,CACLC,qBA9G2BC,MAC3BC,IAEA,IACE,MAAMd,QAAoBe,UAAUC,aAAaC,aAC/CH,GAAc,CAAEI,OAAO,IAEzBnB,EAAMC,YAAcA,EACpB,MAAOmB,GACPC,OAAOC,MAAM,uDAsGfC,eAlGqBT,OACrBU,YACAC,aAAa,KACbC,uBAAsB,EACtBC,sBAEA,IAAK3B,EAAMC,YACT,MAAM,IAAI2B,MAAM,2CAElBxB,EAAe,IAAIyB,aAAa,CAAEJ,eAElCpB,EAAYD,EAAa0B,wBAAwB9B,EAAMC,aAGvDK,EAAeF,EAAa2B,iBAC5BzB,EAAa0B,QAAU,IAEI,YAAvB5B,EAAaJ,aACTI,EAAa6B,SAGrB,MAAMC,EAAgB,KACpB,MAAMC,EAAM,IAAIC,WAAW9B,EAAa+B,mBACxC/B,EAAagC,qBAAqBH,GAClC,MAAMI,EAAUJ,EAAIK,QAAO,CAACC,EAAGC,IAAMD,EAAIC,IAAKP,EAAIQ,OAClD3C,EAAMG,OAASyC,KAAKC,MAAMN,GAAW,IAET,YAAxBnC,GAAcJ,OAChB8C,sBAAsBZ,UAKpB9B,EAAa2C,aAAaC,UAAUpD,GAC1CW,EAAmB,IAAI0C,iBACrB7C,EACA,8BAEFG,EAAiB2C,KAAKC,UAAaC,IACjC,MAAMC,KAAEA,GAASD,EACjB,GAAsB,MAAlBC,EAAKC,UAAmB,CAC1B,MAAMA,EAAYD,EAAKC,UACjBC,EAAU,IAAI7D,KAAK,CAAC4D,GAAY,CAAE3D,KAAM,cAE9C,QAAkB6D,IAAdhC,GAA2BG,EAE7B,YADAA,EAAgB4B,GAId9C,IACFA,EAAmB8C,GACnB9C,EAAqB,aAKT+C,IAAdhC,IACFhB,EAAgBiD,aAAY,KAC1BlD,EAAiB2C,KAAKQ,YAAY,QAAQ,GACzClC,IAGLnB,EAAUsD,QAAQrD,GAClBA,EAAaqD,QAAQpD,GAEjBmB,GACFQ,IAGFlC,EAAME,aAAc,CAAI,EA8BxB0D,cA3BqBC,IAChB7D,EAAME,cAEXO,EAAqBoD,GAAM,KAE3BtD,EAAiB2C,KAAKQ,YAAY,SAClCI,cAActD,GAEdH,EAAU0D,WAAWzD,GACrBA,EAAayD,WAAWxD,GAExBG,IACAV,EAAME,aAAc,EACpBF,EAAMG,OAAS,EAAC,EAehB6D,mBAZyB,KAlHA,MAArBhE,EAAMC,aACRD,EAAMC,aAAagE,YAAYC,SAASC,IACtCA,EAAMC,MAAM,IAkHhB1D,IACAV,EAAMC,YAAc,IAAI,EAUxBoE,SAPe,KAAA,IAAYrE,IAS/B"}