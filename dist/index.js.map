{"version":3,"file":"index.js","mappings":"AACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,sBCAlF,MAyEMI,EAAS,IAAIC,KAAK,CAzES,qqEAyEmB,CAChDC,KAAM,2BAGGC,EADDC,IAAIC,gBAAgBL,GC3EhC,SAASM,IACL,MAAMC,EAAQ,CACVC,YAAa,KACbC,aAAa,EACbC,OAAQ,GAEZ,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACJ,MAOMC,EAAoB,KACF,MAAhBN,GACAA,EAAaO,QAAQC,OAAM,QAC/B,EAkFJ,MAAO,CACHC,qBAjFyBC,MAAOC,IAChC,IACI,MAAMd,QAAoBe,UAAUC,aAAaC,aAAaH,GAAc,CAAEI,OAAO,IACrFnB,EAAMC,YAAcA,CACxB,CACA,MAAOmB,GACHC,OAAOC,MAAM,oDACjB,GA2EAC,eAzEmBT,OAASU,YAChCC,aAAa,KACbC,uBAAsB,EAAMC,sBACxB,IAAK3B,EAAMC,YACP,MAAM,IAAI2B,MAAM,2CAEpBxB,EAAe,IAAIyB,aAAa,CAAEJ,eAClCpB,EAAYD,EAAa0B,wBAAwB9B,EAAMC,aAEvDK,EAAeF,EAAa2B,iBAC5BzB,EAAa0B,QAAU,IACI,YAAvB5B,EAAaJ,aACPI,EAAa6B,SAEvB,MAAMC,EAAgB,KAClB,MAAMC,EAAM,IAAIC,WAAW9B,EAAa+B,mBACxC/B,EAAagC,qBAAqBH,GAClC,MAAMI,EAAUJ,EAAIK,QAAO,CAACC,EAAGC,IAAMD,EAAIC,IAAKP,EAAIQ,OAClD3C,EAAMG,OAASyC,KAAKC,MAAMN,GAAW,IACT,YAAxBnC,GAAcJ,OACd8C,sBAAsBZ,EAC1B,QAGE9B,EAAa2C,aAAaC,UAAUpD,GAC1CW,EAAmB,IAAI0C,iBAAiB7C,EAAc,8BACtDG,EAAiB2C,KAAKC,UAAaC,IAC/B,MAAM,KAAEC,GAASD,EACjB,GAAsB,MAAlBC,EAAKC,UAAmB,CACxB,MAAMA,EAAYD,EAAKC,UACjBC,EAAU,IAAI7D,KAAK,CAAC4D,GAAY,CAAE3D,KAAM,cAC9C,QAAkB6D,IAAdhC,GAA2BG,EAE3B,YADAA,EAAgB4B,GAGhB9C,IACAA,EAAmB8C,GACnB9C,EAAqB,KAE7B,QAEc+C,IAAdhC,IACAhB,EAAgBiD,aAAY,KACxBlD,EAAiB2C,KAAKQ,YAAY,QAAQ,GAC3ClC,IAEPnB,EAAUsD,QAAQrD,GAClBA,EAAaqD,QAAQpD,GACjBmB,GACAQ,IAEJlC,EAAME,aAAc,CAAI,EAuBxB0D,cArBmBC,IACd7D,EAAME,cAEXO,EAAqBoD,GAAM,KAC3BtD,EAAiB2C,KAAKQ,YAAY,SAClCI,cAActD,GACdH,EAAU0D,WAAWzD,GACrBA,EAAayD,WAAWxD,GACxBG,IACAV,EAAME,aAAc,EACpBF,EAAMG,OAAS,EAAC,EAYhB6D,mBAVuB,KArFE,MAArBhE,EAAMC,aACND,EAAMC,aAAagE,YAAYC,SAASC,IACpCA,EAAMC,MAAM,IAqFpB1D,IACAV,EAAMC,YAAc,IAAI,EAQxBoE,SANa,KAAM,IAAMrE,IAQjC,C","sources":["webpack://web-audio-recorder-wav/webpack/bootstrap","webpack://web-audio-recorder-wav/webpack/runtime/define property getters","webpack://web-audio-recorder-wav/webpack/runtime/hasOwnProperty shorthand","webpack://web-audio-recorder-wav/./src/worklet/recorderWorkletProcessor.ts","webpack://web-audio-recorder-wav/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const recorderWorkletProcessor = `\nclass RecorderWokletProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super()\n    this.bufferChunks = []\n    this.port.onmessage = event => {\n      if (event.data === 'flush') {\n        this.flush()\n      }\n    }\n  }\n\n  process(inputs) {\n    const input = inputs[0]\n    if (input.length > 0) {\n      const channelData = input[0] // only mono channel\n      this.bufferChunks.push(new Float32Array(channelData))\n    }\n    return true\n  }\n\n  flush() {\n    if (this.bufferChunks.length > 0) {\n      const wavBuffer = this.encodeWAV(this.bufferChunks, sampleRate)\n      this.port.postMessage({ wavBuffer }, [wavBuffer])\n      this.bufferChunks = []\n    }\n  }\n\n  encodeWAV(samples, sampleRate) {\n    const WAV_HEADER_LENGTH = 44 // bytes\n    const bufferLength = samples.length * samples[0].length * 2\n    const buffer = new ArrayBuffer(WAV_HEADER_LENGTH + bufferLength)\n    const view = new DataView(buffer)\n\n    // pack WAV header\n    this.writeString(view, 0, 'RIFF')\n    view.setUint32(4, 36 + bufferLength, true)\n    this.writeString(view, 8, 'WAVE')\n    this.writeString(view, 12, 'fmt ')\n    view.setUint32(16, 16, true) // SubChunk1Size\n    view.setUint16(20, 1, true) // AudioFormat (PCM)\n    view.setUint16(22, 1, true) // NumChannels\n    view.setUint32(24, sampleRate, true) // SampleRate\n    view.setUint32(28, sampleRate * 2, true) // ByteRate\n    view.setUint16(32, 2, true) // BlockAlign\n    view.setUint16(34, 16, true) // BitsPerSample\n    this.writeString(view, 36, 'data')\n    view.setUint32(40, bufferLength, true)\n\n    // write audio data\n    let offset = WAV_HEADER_LENGTH\n    for (let i = 0; i < samples.length; i++) {\n      const sample = samples[i]\n      for (let j = 0; j < sample.length; j++) {\n        const s = Math.max(-1, Math.min(1, sample[j]))\n        view.setInt16(offset, s * 0x7fff, true)\n        offset += 2 // 2bytes -> 16bitsì”©\n      }\n    }\n\n    return buffer\n  }\n\n  writeString(view, offset, string) {\n    for (let i = 0; i < string.length; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i))\n    }\n  }\n}\n\nregisterProcessor('recorder-worklet-processor', RecorderWokletProcessor)\n`;\nconst script = new Blob([recorderWorkletProcessor], {\n    type: 'application/javascript',\n});\nconst src = URL.createObjectURL(script);\nexport const RecorderWokletProcessorSrc = src;\n","import { RecorderWokletProcessorSrc } from './worklet/recorderWorkletProcessor';\nfunction createAudioRecorder() {\n    const state = {\n        mediaStream: null,\n        isRecording: false,\n        volume: 0,\n    };\n    let audioContext;\n    let inputNode;\n    let analyzerNode;\n    let audioWorkletNode;\n    let flushInterval;\n    let handleStopCallback;\n    const stopMediaStream = () => {\n        if (state.mediaStream != null) {\n            state.mediaStream?.getTracks().forEach((track) => {\n                track.stop();\n            });\n        }\n    };\n    const closeAudioContext = () => {\n        if (audioContext != null) {\n            audioContext.close().catch(() => { });\n        }\n    };\n    const requestMicPermission = async (contraints) => {\n        try {\n            const mediaStream = await navigator.mediaDevices.getUserMedia(contraints ?? { audio: true });\n            state.mediaStream = mediaStream;\n        }\n        catch (err) {\n            window.alert('You do not have permission for microphone access.');\n        }\n    };\n    const startRecording = async ({ timeSlice, // ms\n    sampleRate = 44000, // hz\n    enableAnalyzeVolume = true, onDataAvailable, }) => {\n        if (!state.mediaStream) {\n            throw new Error('startRecording: no media stream exists!');\n        }\n        audioContext = new AudioContext({ sampleRate });\n        inputNode = audioContext.createMediaStreamSource(state.mediaStream);\n        // analyze volume from 0~1\n        analyzerNode = audioContext.createAnalyser();\n        analyzerNode.fftSize = 256;\n        if (audioContext.state !== 'running') {\n            await audioContext.resume(); // for safari\n        }\n        const analyzeVolume = () => {\n            const arr = new Uint8Array(analyzerNode.frequencyBinCount);\n            analyzerNode.getByteFrequencyData(arr); // amplitude of each frequency bin from 0 to 255\n            const average = arr.reduce((a, b) => a + b) / arr.length;\n            state.volume = Math.round(average) / 100;\n            if (audioContext?.state === 'running') {\n                requestAnimationFrame(analyzeVolume);\n            }\n        };\n        // pcm -> wav encode\n        await audioContext.audioWorklet.addModule(RecorderWokletProcessorSrc);\n        audioWorkletNode = new AudioWorkletNode(audioContext, 'recorder-worklet-processor');\n        audioWorkletNode.port.onmessage = (event) => {\n            const { data } = event;\n            if (data.wavBuffer != null) {\n                const wavBuffer = data.wavBuffer;\n                const wavBlob = new Blob([wavBuffer], { type: 'audio/wav' });\n                if (timeSlice !== undefined && onDataAvailable) {\n                    onDataAvailable(wavBlob);\n                    return;\n                }\n                if (handleStopCallback) {\n                    handleStopCallback(wavBlob);\n                    handleStopCallback = null;\n                }\n            }\n        };\n        if (timeSlice !== undefined) {\n            flushInterval = setInterval(() => {\n                audioWorkletNode.port.postMessage('flush');\n            }, timeSlice);\n        }\n        inputNode.connect(analyzerNode);\n        analyzerNode.connect(audioWorkletNode);\n        if (enableAnalyzeVolume) {\n            analyzeVolume();\n        }\n        state.isRecording = true;\n    };\n    const stopRecording = (cb) => {\n        if (!state.isRecording)\n            return;\n        handleStopCallback = cb ?? null;\n        audioWorkletNode.port.postMessage('flush');\n        clearInterval(flushInterval);\n        inputNode.disconnect(analyzerNode);\n        analyzerNode.disconnect(audioWorkletNode);\n        closeAudioContext();\n        state.isRecording = false;\n        state.volume = 0;\n    };\n    const destroyMediaStream = () => {\n        stopMediaStream();\n        closeAudioContext();\n        state.mediaStream = null;\n    };\n    const getState = () => ({ ...state });\n    return {\n        requestMicPermission,\n        startRecording,\n        stopRecording,\n        destroyMediaStream,\n        getState,\n    };\n}\nexport { createAudioRecorder };\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","script","Blob","type","RecorderWokletProcessorSrc","URL","createObjectURL","createAudioRecorder","state","mediaStream","isRecording","volume","audioContext","inputNode","analyzerNode","audioWorkletNode","flushInterval","handleStopCallback","closeAudioContext","close","catch","requestMicPermission","async","contraints","navigator","mediaDevices","getUserMedia","audio","err","window","alert","startRecording","timeSlice","sampleRate","enableAnalyzeVolume","onDataAvailable","Error","AudioContext","createMediaStreamSource","createAnalyser","fftSize","resume","analyzeVolume","arr","Uint8Array","frequencyBinCount","getByteFrequencyData","average","reduce","a","b","length","Math","round","requestAnimationFrame","audioWorklet","addModule","AudioWorkletNode","port","onmessage","event","data","wavBuffer","wavBlob","undefined","setInterval","postMessage","connect","stopRecording","cb","clearInterval","disconnect","destroyMediaStream","getTracks","forEach","track","stop","getState"],"sourceRoot":""}